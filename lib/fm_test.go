// Spies generated by fm. Do not edit.
// Regenerate by running fm instead.
package fm_test

import (
	"go/ast"
	"sync"
)

type SpyStructConverter struct {
	mu             sync.Mutex
	Convert_Called bool
	Convert_Input  struct {
		Arg0 *ast.TypeSpec
		Arg1 *ast.InterfaceType
	}
	Convert_Output struct {
		Ret0 *ast.TypeSpec
	}
}

func (f *SpyStructConverter) Convert(t *ast.TypeSpec, i *ast.InterfaceType) *ast.TypeSpec {
	f.mu.Lock()
	defer f.mu.Unlock()
	f.Convert_Called = true
	f.Convert_Input.Arg0 = t
	f.Convert_Input.Arg1 = i
	return f.Convert_Output.Ret0
}

type SpyFuncImplementer struct {
	mu               sync.Mutex
	Implement_Called bool
	Implement_Input  struct {
		Arg0 *ast.Ident
		Arg1 *ast.InterfaceType
	}
	Implement_Output struct {
		Ret0 []*ast.FuncDecl
	}
}

func (f *SpyFuncImplementer) Implement(name *ast.Ident, i *ast.InterfaceType) []*ast.FuncDecl {
	f.mu.Lock()
	defer f.mu.Unlock()
	f.Implement_Called = true
	f.Implement_Input.Arg0 = name
	f.Implement_Input.Arg1 = i
	return f.Implement_Output.Ret0
}

type SpyDeclGenerator struct {
	mu              sync.Mutex
	Generate_Called bool
	Generate_Input  struct {
		Arg0 []ast.Decl
	}
	Generate_Output struct {
		Ret0 []ast.Decl
	}
}

func (f *SpyDeclGenerator) Generate(ds []ast.Decl) []ast.Decl {
	f.mu.Lock()
	defer f.mu.Unlock()
	f.Generate_Called = true
	f.Generate_Input.Arg0 = ds
	return f.Generate_Output.Ret0
}

type SpyParser struct {
	mu              sync.Mutex
	ParseDir_Called bool
	ParseDir_Input  struct {
		Arg0 string
	}
	ParseDir_Output struct {
		Ret0 map[string]*ast.Package
		Ret1 error
	}
}

func (f *SpyParser) ParseDir(dir string) (map[string]*ast.Package, error) {
	f.mu.Lock()
	defer f.mu.Unlock()
	f.ParseDir_Called = true
	f.ParseDir_Input.Arg0 = dir
	return f.ParseDir_Output.Ret0, f.ParseDir_Output.Ret1
}

type SpyWriter struct {
	mu           sync.Mutex
	Write_Called bool
	Write_Input  struct {
		Arg0 *ast.File
		Arg1 string
	}
	Write_Output struct {
		Ret0 error
	}
}

func (f *SpyWriter) Write(file *ast.File, filename string) error {
	f.mu.Lock()
	defer f.mu.Unlock()
	f.Write_Called = true
	f.Write_Input.Arg0 = file
	f.Write_Input.Arg1 = filename
	return f.Write_Output.Ret0
}

type SpyImportWriter struct {
	mu           sync.Mutex
	Write_Called bool
	Write_Input  struct {
		Arg0 string
	}
	Write_Output struct {
		Ret0 error
	}
}

func (f *SpyImportWriter) Write(filename string) error {
	f.mu.Lock()
	defer f.mu.Unlock()
	f.Write_Called = true
	f.Write_Input.Arg0 = filename
	return f.Write_Output.Ret0
}
